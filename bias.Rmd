---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---


## Make Phyloseq object

Following taxonomic assignment, the sequence table and taxonomic table are merged into a single phyloseq object alongside the sample info csv.

We then make a plot to evaluate the effectiveness of taxonomic assignment to each rank

```{r create PS, eval = FALSE}
seqtab.nochim <- read_rds("output/rds/seqtab_final.rds")

##Fix seqtab names -removing read name, sample number etc
#rownames(seqtab.nochim) <- rownames(seqtab.nochim) %>% 
#  str_split_fixed("_",n=Inf) %>%
#    as_tibble() %>% 
#  separate(V7, into="rep", sep = "\\.", extra = "drop") %>%
#  unite(col=SampleID, c("V2","rep"),sep="-") %>%
#  pull(SampleID) %>%
#  str_replace(pattern="Rep", replacement="rep")
#
#### Rename problematic samples
#rownames(seqtab.nochim)  <- rownames(seqtab.nochim) %>%
#  str_replace_all("CM9", "CM8")%>%
#  str_replace_all("CM10", "CM9")%>%
#  str_replace_all("CM11", "CM10")%>%
#  str_replace_all("CML1", "CM11")%>%
#  str_replace_all("CML2", "CML1")%>%
#  str_replace_all("CML3", "CML2")%>%
#  str_replace_all("CML4", "CML3")%>%
#  str_replace_all("CML5", "CML4")%>%
#  str_replace_all("CML6", "CML5")%>%
#  str_replace_all("CT1", "CML6")%>%
#  str_replace_all("CT2", "CT1")%>%
#  #str_replace_all("CT3", "CT2")%>%
#  #str_replace_all("CT4", "CT3")%>%
#  str_replace_all("CT5", "CT11")%>% # NEED TO CHECK THIS
#  str_replace_all("CT5dup", "CT5")

#Run 1 
rownames(seqtab.nochim) <- rownames(seqtab.nochim) %>% 
  str_split_fixed("_",n=Inf) %>%
    as_tibble() %>% 
  pull(V1)

tax_plus <- read_rds("output/rds/tax_IdTaxaExact.rds") 

#Load sample information
## ---- samdat ----
samdf <- read.csv("sample_data/Sample_info.csv", header=TRUE) %>%
  filter(!duplicated(sample_id)) %>%
  filter(FCID== "CB3DR") %>% # change for other runs
  magrittr::set_rownames(.$sample_id) %>%
  dplyr::select(c("sample_id", "ExtractID",
                  "geo_loc_name", "material", "treatment", "material",
                  "target_subfragment", "F_primer", "R_primer",
                  "FCID", "seq_platform_ID"))
#Display samDF
head(samdf)

## ---- phyloseq ----
ps <- phyloseq(tax_table(tax_plus), sample_data(samdf),
               otu_table(seqtab.nochim, taxa_are_rows = FALSE))

if(nrow(seqtab.nochim) > nrow(sample_data(ps))){warning("Warning: All samples not included in phyloseq object, check sample names match the sample metadata")}

rownames(samdf)[which(!rownames(sample_data(ps))  %in% rownames(samdf))]

## Subset to carpophilus

#Rename synthetic orders
tax_table(ps)[,2][which(str_detect(tax_table(ps)[,7], "Synthetic"))] <- "Arthropoda"

ps <- ps %>%
  subset_samples(material %in% c("Carpophilus Adults","Carpophilus Larvae")) %>%
  subset_taxa(Phylum == "Arthropoda") %>%
  filter_taxa( function(x) mean(x) > 0, TRUE) 

rm_samples <- "CT11|CM7|CT3"
ps <- subset_samples(ps, !str_detect(sample_names(ps), rm_samples)) # Drop Undetermined reads

```


## Process replicates 

In this section we will estimate within sample consistency using Kulczynski distance, which is a presence/absense distance measure.

To ensure the reproducibility of detection, all PCR replicates that had a high Kulczynski distance to other replicates within the same sample were removed.

Following this, we only retained ASV's that were present in at least 2 different replicates from each sample

Adapted from Mike mclarens code: https://github.com/benjjneb/dada2/issues/745

This could probably go before taxonomic assignment?

```{r replicates}

# Merge replicates
  ps.merged <- ps %>%
    merge_samples(group = "ExtractID")

#This loses the sample metadata - Need to add it agian
samdf <- read.csv("sample_data/Sample_info.csv", header=TRUE)  %>%
  filter(!duplicated(ExtractID))  %>%
  magrittr::set_rownames(.$ExtractID) %>%
  dplyr::select(c("sample_id", "ExtractID",
                  "geo_loc_name", "material", "treatment",
                  "target_subfragment", "F_primer", "R_primer",
                  "FCID", "seq_platform_ID"))

sample_data(ps.merged) <- samdf
ps.merged <- filter_taxa(ps.merged, function(x) mean(x) > 0, TRUE) #Drop missing taxa from table

```




As part of the mock community analysis, we wish to determine taxonomic bias by looking at observed vs expected reads. To do this, we load dummy sequence, taxonomy, and sample data tables and create a seperate phyloseq object, which will later be merged

This loads a dummy sequence table, taxonomy table, and sample data table and merges it into the existing phyloseq object

Conducted as per: https://mikemc.github.io/metacal/articles/tutorial.html


The clr-transformed values are scale-invariant; that is the same ratio is expected to be obtained in a sample with few read counts or an identical sample with many read counts, only the precision of the clr estimate is affected. 

The G(x) cannot be determined for sparse data without deleting, replacing or estimating the 0 count values. Fortunately, there are acceptable methods of dealing with 0 count values as both point estimates using zCompositionsR package

```{r Carpophilus bias}
#Remove anything not assigned below the root rank
#ps.filt <- ps.merged %>%
#  subset_samples(!str_detect(sample_names(ps.merged), "-s-"))

#Agglomerate to species and subset to primers
ps_bias <- ps
tax_table(ps_bias)[,7][which(tax_table(ps_bias)[,7]=="Carpophilus_dimidiatus/nr.dimidiatus")] <- "Carpophilus_nr.dimidiatus"
tax_table(ps_bias)[,7][which(tax_table(ps_bias)[,7]=="Brachypeplus_Sp1")] <- "Brachypeplus_Sp"
tax_table(ps_bias)[,7][which(tax_table(ps_bias)[,7]=="Brachypeplus_Sp2")] <- "Brachypeplus_Sp"
ps_bias <- tax_glom(ps_bias, taxrank="Species")

taxa_names(ps_bias) <- paste0("SV", seq(ntaxa(ps_bias)),"-",tax_table(ps_bias)[,7])

sam <- psmelt(ps_bias) %>%
  arrange(Abundance)%>%
  mutate(Taxon = Species) %>%
  mutate(OTU = str_replace_all(OTU, pattern="Brachypeplus_Sp1", replacement = "Brachypeplus_Sp")) %>%
  mutate(OTU = str_replace_all(OTU, pattern="Brachypeplus_Sp2", replacement = "Brachypeplus_Sp")) %>%
  distinct()

exp <- read_csv("sample_data/expected_quant_EDIT.csv") %>%
  gather(Species, Abundance, -X1) %>%
  mutate(Species = str_replace(Species, pattern=" ",replacement="_")) %>%
  filter(str_detect(X1,"CM|CT")) %>%
  drop_na() %>%
  set_colnames(c("Sample","Taxon","Actual"))

#Subset to only those taxa desired for estimation
#controls <- c("CM1-ex1","CM2-ex1","CM3-ex1","CM5-ex1", "CM6-ex1", "CM6-ex2","CM9-ex1","CM9-ex2")
#controls <- c("CM6-ex1","CM6-ex2","CM7-ex1","CM7-ex2","CM9-ex1","CM9-ex2")
#Join tables 
joint <- sam %>%
  filter(Taxon %in% exp$Taxon) %>%
  filter(material =="Carpophilus Adults") %>%
  group_by(Taxon, Sample, target_subfragment, material) %>% 
  summarise(Abundance = sum(Abundance)) %>%
  ungroup() %>%
 # filter(target_subfragment == "fwhF2-fwhR2n") %>%
  #mutate(Type = ifelse(Sample %in% controls, "Est", "Eval")) %>%
  left_join(exp, by = c("Sample","Taxon")) %>%
  mutate(Actual = replace_na(Actual, 0)) %>%
  mutate(Observed0 = (Abundance + 0.5) * (Actual > 0)) %>%
  mutate(Error = Observed0 / Actual) %>%
  distinct()

#Estimate bias by target_
bias <- joint %>%
    group_by(target_subfragment, Taxon) %>%
    summarize(Bias = gm_mean(Error)) %>%
    mutate(Bias = center_elts(Bias)) %>%
    ungroup


stm <- joint %>%
    left_join(bias, by = c("target_subfragment", "Taxon")) %>%
    mutate(
        Residual = Error / Bias,
        Predicted = Actual * Bias
    )

reps <- stm %>%
    group_by(target_subfragment) %>%
    nest %>%
    mutate(
        Error_matrix = map(data, build_matrix, "Sample", "Taxon", "Error"),
        Bootreps = map(Error_matrix, bootrep_center, R = 4e3, 
            method = "proj"))%>%
    unnest(Bootreps) %>%
    dplyr::rename(Bias = Center)
stats <- reps %>%
    group_by(target_subfragment, Taxon) %>%
    summarize(gm_mean = gm_mean(Bias), gm_se = gm_sd(Bias)) %>%
    ungroup

bias <- left_join(bias, stats, by = c("target_subfragment", "Taxon"))

#Plot bootstraps
library(ggridges)
gg.boot <- ggplot(reps, aes(x = Bias-1, y = Taxon, fill=Taxon)) +
    geom_density_ridges(scale = 4) + 
  #theme_ridges() +
    geom_vline(xintercept = 0, color = "black", size=2) +
  facet_wrap(~target_subfragment) +
  scale_y_discrete(expand = c(0.01, 0)) +   # will generally have to set the `expand` option
  scale_x_continuous(expand = c(0, 0), limits=c(-1, 4)) + 
  ggtitle("Bootstrap standard errors of bias estimates for each primer set") +
  scale_fill_brewer(palette = "Spectral") + 
  xlab("Efficiancy / Geometric mean") 

gg.boot

## Calculate SE as control samples increase
mat <- stm %>%
    filter(target_subfragment == "fwhF2-fwhR2n") %>%
    build_matrix(Sample, Taxon, Error)

N <- 1:20
names(N) <- N

reps <- map_dfr(N, ~bootrep_center(reps$Error_matrix[[1]], R = 4e3, dist = "multinomial",
        N = ., method = "proj"),
    .id = "N") %>%
    dplyr::rename(Bhat = Center)

reps.summary <- reps %>%
    group_by(N, Taxon) %>%
    summarize(gm_mean = gm_mean(Bhat), gm_se = gm_sd(Bhat))

r <- range(reps.summary$gm_se)
names(r) <- r  %>% round(2)

gg.se <- ggplot(reps.summary, aes(x= as.numeric(N), y=gm_se, color = Taxon)) +
    geom_line(aes(group = Taxon), size=1) +
    geom_point() +
    scale_y_continuous(limits = range(c(1, r)), ) +
    scale_color_brewer(palette="Spectral") +
    #scale_color_manual(values = values.color, labels = tax_labeller) +
    #geom_rangeframe(color = "black") +
    #theme_bw() +
    labs(x = "Number of controls", y = "Geometric standard error", 
        title = "Standard error vs. number of control samples", 
        color = "Taxon")
gg.se

```

# Calibration

## Mclaren model
```{R}
#Calibration
cal <- joint %>%
    left_join(bias, by = c("Taxon", "target_subfragment")) %>%
    dplyr::mutate(Calibrated = Abundance / Bias) 

#To scale with spike in, multiply everything by difference between observed reads and expected COI copies for the spikes

# Could assume that all other taxa have a bias of 1 and just set them to that?
cal.prop <- cal %>%
    #filter(Taxon %in% (joint %>% filter(Type =="Est") %>% filter(Actual > 0) %>% pull(Taxon) %>% unique())) %>%
    group_by(Sample, target_subfragment) %>%
    mutate_at(vars(Abundance, Calibrated, Actual), ~ . / sum(.)) 

cal.prop <- cal.prop %>%
    gather("Type", "Proportion", "Abundance", "Calibrated", "Actual") %>%
    mutate(Type = factor(Type, c("Actual","Abundance", "Calibrated"))) %>%
  ggplot(aes(Type, Proportion, fill = Taxon)) +
    geom_col() +
    facet_wrap(target_subfragment~Sample, drop=TRUE) +
    theme_bw() +
    scale_fill_brewer(palette = "Spectral") +
  ggtitle("Calibration using model of Mclaren et al 2019")

#also make another plot showing the bias in the estimates from the amount of controls used - see https://mikemc.github.io/mgs-bias-manuscript/analysis/costea2017-analysis.html

```

## Linear model
```{r Linear model}
## Linear model
main1 <- joint %>%
  #filter(material == "Carpophilus Adults") %>%
  #filter(Type=="Est") %>%
  #filter(Taxon %in% (joint %>% filter(Type =="Est") %>% filter(Actual > 0) %>% pull(Taxon) %>% unique())) %>%
  group_by(Sample) %>%
  mutate_at(vars(Abundance, Actual), ~ . / sum(.))%>%
  dplyr::select(Sample, Taxon, Abundance, Actual, target_subfragment, material) %>% 
  ungroup()



bias.slm <- main1 %>%
    group_by(target_subfragment, Taxon) %>%
    nest() %>%
    mutate(fit = map(data, ~lm(Abundance ~ 0 + Actual, data = .)),
           tidied = map(fit, broom::tidy)) %>%
  #unnest(data) %>%
  unnest(tidied) %>%
  select(Taxon, estimate, std.error, target_subfragment)


gg.linearcal <- joint %>%
    left_join(bias.slm, by = c("Taxon", "target_subfragment")) %>%
    mutate(Calibrated = Abundance / estimate) %>%
    group_by(Sample, target_subfragment) %>%
  #filter(Taxon %in% (joint %>% filter(Type =="Est") %>% filter(Actual > 0) %>% pull(Taxon) %>% unique()))%>%
    mutate_at(vars(Abundance, Calibrated, Actual), ~ . / sum(.))  %>%
    gather("Type", "Proportion", "Abundance", "Calibrated", "Actual") %>%
    mutate(Type = factor(Type, c("Actual","Abundance", "Calibrated"))) %>%
  ggplot(aes(Type, Proportion, fill = Taxon)) +
    geom_col() +
    facet_wrap(target_subfragment~Sample, drop=TRUE) +
    theme_bw() +
    scale_fill_brewer(palette = "Spectral") +
  ggtitle("Calibration using linear model")

```


# Compare models
```{r Compare models}
#Plot expected vs observed

correction <- joint %>%
    #filter(material == "Carpophilus Adults") %>%
    left_join(bias, by = c("Taxon", "target_subfragment")) %>%
    mutate(Calibrated = Abundance / Bias) %>%
    left_join(bias.slm, by = c("Taxon", "target_subfragment")) %>%
    mutate(lm = Abundance / estimate) %>%
    group_by(Sample, target_subfragment) %>%
  #filter(Taxon %in% (joint %>% filter(Type =="Est") %>% filter(Actual > 0) %>% pull(Taxon) %>% unique()))%>%
    mutate_at(vars(Abundance, Calibrated, Actual, lm), ~ . / sum(.)) %>% 
    ungroup() %>%
    dplyr::select(Sample, material, target_subfragment, Taxon, Actual, Calibrated, Abundance, lm) %>%
  dplyr::rename(Observed = Abundance) %>%
  tidyr::gather(Type, Abundance, -Sample, -Taxon, -Actual, -material, -target_subfragment)  %>%
  mutate(Type = factor(Type, levels = c("Observed", "lm", "Calibrated"))) %>%
  filter(!is.nan(Abundance), Actual > 0) %>%
  distinct()

#To scale with spike in, multiply everything by difference between observed reads and expected COI copies for the spikes

#col <- c(Observed= "#f7f7f7", lm = "#ef8a62", Calibrated = "#67a9cf")

gg.cor <- ggplot(correction, aes(x=Actual,y=Abundance)) +
  geom_point(aes(colour=Type, shape=Type), size=3, alpha=0.8, stroke=1) + 
  geom_abline(slope=1, intercept = 0) +
  stat_cor(aes(color=Type), label.x = 0.1)  + 
  facet_grid(~target_subfragment) +
  #xlim(0,1) + 
  #ylim(0,1) + 
  #scale_fill_manual(values=col) + 
  #scale_colour_manual(values=col) +
  #theme_bw() + 
  ylab("Observed")


preds <- joint %>%
    #filter(material == "Carpophilus Adults") %>%
    left_join(bias, by = c("Taxon", "target_subfragment")) %>%
    mutate(Calibrated = Abundance / Bias) %>%
    left_join(bias.slm, by = c("Taxon", "target_subfragment")) %>%
    mutate(lm = Abundance / estimate) %>%
    mutate(Counts = Observed0) %>%
    group_by(Sample, target_subfragment) %>%
    mutate_at(vars(Observed0, Calibrated, Actual, lm, Counts), ~ . / sum(.)) %>% 
    ungroup() %>%
    gather("Model", "Predicted", Calibrated, lm, Counts)


ggplot(preds, aes(logit(Predicted), logit(Observed0), color = Taxon)) +
    geom_abline(intercept = 0, slope = 1, color = "grey") +
    geom_jitter(width = 0.1, height = 0) +
    facet_grid(target_subfragment ~ Model) +
    labs(x = "log-odds(Predicted proportion)", 
        y = "log-odds(Observed proportion)") +
    coord_fixed() +
    theme(
        panel.spacing.x = unit(1, "lines"),
        legend.position = "bottom",
    ) + scale_color_brewer(palette="Spectral")
```


# Calibrating batch effects

```{r}
#Estimate differential bias to one 'reference' protocol (or primer)
stmW <- joint %>%
    select(Taxon, Sample, target_subfragment, Observed0) %>%
    mutate(Sample =str_split_fixed(Sample, "-", n=3) %>% as_tibble() %>% pull(V3)) %>%
    spread(target_subfragment, Observed0) %>%
    dplyr::mutate(Actual = `BF1-BR1`) %>%
    gather("target_subfragment", "Observed", `BF1-BR1`, `fwhF2-fwhR2n`, `fwhF2-HexCOIR4`, `SauronS878-HexCOIR4`) %>%
    mutate(Error = Observed / Actual)
biasW_est <- stmW %>%
    #filter(Set == "Est") %>%
    group_by(target_subfragment, Taxon) %>%
    summarize(BiasW = gm_mean(Error)) %>%
    mutate(BiasW = center_elts(BiasW))
biasW_est %>%
    spread(target_subfragment, BiasW)

#Calibrate all samples
stm0 <- joint %>%
    left_join(bias, by = c("target_subfragment", "Taxon")) %>%
    left_join(biasW_est, by = c("target_subfragment", "Taxon")) %>%
    mutate_by(Sample, 
        Calibrated_to_Actual = close_elts(Observed0 / Bias),
        Calibrated_to_W = close_elts(Observed0 / BiasW)
    )

stm1 <- stm0 %>%
    gather("Type", "Abundance", 
        Observed0, Actual, Calibrated_to_Actual, Calibrated_to_W) %>%
    select(Taxon, Sample, target_subfragment, Type, Abundance) %>%
    group_by(Sample, Type) %>%
    mutate(Clr = clr(Abundance)) %>%
    ungroup

#Get matrix with saples as rows for PCA
temp <- stm1 %>%
    unite("Sample_Type", Sample, Type, sep = ":") %>%
    select(Sample_Type, Taxon, Clr) %>%
    spread(Taxon, Clr)
mat <- temp %>%
    select(-Sample_Type) %>%
    as("matrix")
rownames(mat) <- temp$Sample_Type
corner(mat)

#PCA
pcx <- prcomp(mat)
tb <- as_tibble(pcx$x[,c(1,2)], rownames='Sample_Type') %>%
    separate(Sample_Type, c("Sample", "Type"), sep = ":") %>%
    left_join(sam, by = "Sample")
tb <- tb %>%
    mutate(PC1 = -PC1, PC2 = PC2)

fracvar <- pcx$sdev^2/sum(pcx$sdev^2)
round(fracvar, 3)

facet_labeller <- function (tb) {
    tb %>% 
        mutate_all(str_replace_all, "_", " ") %>%
        mutate_all(str_replace, " ", "\n")
}
type.lvls <- c("Observed", "Calibrated_to_Actual", "Calibrated_to_W")
actual <- tb %>%
    filter(Type == "Actual", Sample == "H1") %>%
    select(PC1, PC2) %>%
    expand(Type = factor(type.lvls, type.lvls), PC1, PC2)
tb0 <- tb %>%
    filter(Type != "Actual") %>%
    mutate(Type = factor(Type, type.lvls))
tb.breaks <- 
    tribble(
        ~PC1, ~PC2,
        # min(tb0$PC1), min(tb0$PC2),
        # actual$PC1[1], actual$PC2[1],
        # max(tb0$PC1), max(tb0$PC2),
        )
tb.range <- 
    tribble(
        ~PC1, ~PC2,
        min(tb0$PC1), min(tb0$PC2),
        max(tb0$PC1), max(tb0$PC2),
        )
p.pca <- ggplot(tb0, aes(PC1, PC2, color = Protocol, shape = Set)) +
    geom_point(data = actual, aes(PC1, PC2),
        shape = 3, size = 4, color = "black") +
    geom_point() +
    facet_grid(Type ~ ., labeller = facet_labeller) +
    geom_rangeframe(data = tb.range, aes(PC1, PC2), 
        color = "black", inherit.aes = FALSE) + 
    scale_x_continuous(breaks = tb.breaks$PC1, labels = NULL) +
    scale_y_continuous(breaks = tb.breaks$PC2, labels = NULL) +
    scale_shape_manual(breaks = c("Est", "Eval"), values = c(1, 16)) +
    scale_color_manual(values = colors.protocol) + 
    base_theme +
    theme(strip.text.y = element_text(angle=0, size = 9)) +
    # theme(axis.line = element_line()) +
    labs(title = "Sample ordination", x = strvar[1], y = strvar[2])
# Label the protocols in the "Observed" plot
labtb <- tribble(
    ~x,     ~y,   ~Protocol,
    -4,    1.5,   "H",
    -0.5,  1.3,   "Q",
    -1.85, -0.4,  "W",
    2.3,    0.7,   "Actual"
    ) %>%
    mutate(Type = factor("Observed", type.lvls))
p.pca <- p.pca +
    geom_text(data = labtb,
        aes(x, y, label = Protocol, color = Protocol), 
        size = 3, inherit.aes = FALSE, show.legend = FALSE)
p.pca


```

